//	Библиотека для работы с ИК-приёмником:   http://iarduino.ru/shop/Sensory-Datchiki/ik-priemnik-trema-modul.html
//  И (или)    для работы с ИК-передатчиком: http://iarduino.ru/shop/Expansion-payments/ik-peredatchik-trema-modul.html
//  Версия: 1.0.1
//  Последнюю версию библиотеки Вы можете скачать по ссылке: http://iarduino.ru/file/257.html
//  Подробное описание функции бибилиотеки доступно по ссылке: http://wiki.iarduino.ru/page/ik-priemnik/
//  Библиотека является собственностью интернет магазина iarduino.ru и может свободно использоваться и распространяться!
//  При публикации устройств или скетчей с использованием данной библиотеки, как целиком, так и её частей,
//  в том числе и в некоммерческих целях, просим Вас опубликовать ссылку: http://iarduino.ru
//  Автор библиотеки: Панькин Павел
//  Если у Вас возникли технические вопросы, напишите нам: shop@iarduino.ru

#ifndef iarduino_IR_h
#define iarduino_IR_h

#if defined(ARDUINO) && (ARDUINO >= 100)
#include <Arduino.h>
#else
#include <WProgram.h>
#endif

#if defined(__AVR_ATmega32U4__)													//	Если используется плата на базе микроконтроллера ATmega32U4 (Arduino Micro или Arduino Leonardo), то ...
#if !defined(TCCR2A)															//	Если Arduino IDE не знает, что у этих микроконтроллеров есть второй аппаратный таймер, то ...
	#define TCCR2A					(*(uint8_t*)0xB0)							//	Определяем смещение для регистра TCCR2A - регистр выбора режима
	#define COM2A1					7											//	Определяем позицию  в регистре   TCCR2A для старшего бита выбора режима сравнения канала А
	#define COM2A0					6											//	Определяем позицию  в регистре   TCCR2A для младшего бита выбора режима сравнения канала А
	#define COM2B1					5											//	Определяем позицию  в регистре   TCCR2A для старшего бита выбора режима сравнения канала B
	#define COM2B0					4											//	Определяем позицию  в регистре   TCCR2A для младшего бита выбора режима сравнения канала B
	#define WGM21					1											//	Определяем позицию  в регистре   TCCR2A для 1 бита выбора режима работы таймера
	#define WGM20					0											//	Определяем позицию  в регистре   TCCR2A для 0 бита выбора режима работы таймера
	#define TCCR2B					(*(uint8_t*)0xB1)							//	Определяем смещение для регистра TCCR2B - рагистр делителя
	#define FOC2A					7											//	Определяем позицию  в регистре   TCCR2B для бита принудительной установки результата сравнения канала A
	#define FOC2B					6											//	Определяем позицию  в регистре   TCCR2B для бита принудительной установки результата сравнения канала B
	#define WGM22					3											//	Определяем позицию  в регистре   TCCR2B для 2 бита выбора режима работы таймера
	#define CS22					2											//	Определяем позицию  в регистре   TCCR2B для старшего бита выбора источника тактового сигнала таймера
	#define CS21					1											//	Определяем позицию  в регистре   TCCR2B для среднего бита выбора источника тактового сигнала таймера
	#define CS20					0											//	Определяем позицию  в регистре   TCCR2B для младшего бита выбора источника тактового сигнала таймера
	#define TCNT2					(*(uint8_t*)0xB2)							//	Определяем смещение для регистра TCNT2  - счётный регистр
	#define OCR2A					(*(uint8_t*)0xB3)							//	Определяем смещение для регистра OCR2A  - регистр сравнения канала A
	#define OCR2B					(*(uint8_t*)0xB4)							//	Определяем смещение для регистра OCR2B  - регистр сравнения канала B
	#define TIFR2					(*(uint8_t*)0x37)							//	Определяем смещение для регистра TIFR2  - регистр флагов
	#define OCF2B					2											//	Определяем позицию  в регистре   TIFR2  для флага совпадения значения счетного регистра TCNT2 с регистром сравнения OCR2A
	#define OCF2A					1											//	Определяем позицию  в регистре   TIFR2  для флага совпадения значения счетного регистра TCNT2 с регистром сравнения OCR2B
	#define TOV2					0											//	Определяем позицию  в регистре   TIFR2  для флага переполнения счетного регистра TCNT2
	#define TIMSK2					(*(uint8_t*)0x70)							//	Определяем смещение для регистра TIMSK2 - регистр разрешения прерываний
	#define OCIE2B					2											//	Определяем позицию  в регистре   TIMSK2 для бита разрешения прерываний по установке флага OCF2B
	#define OCIE2A					1											//	Определяем позицию  в регистре   TIMSK2 для бита разрешения прерываний по установке флага OCF2A
	#define TOIE2					0											//	Определяем позицию  в регистре   TIMSK2 для бита разрешения прерываний по установке флага TOF2
	#define TIMER2_COMPA_vect_num	13											//	Определяем номер  вектора  для  события установки флага OCF2A
	#define TIMER2_COMPA_vect		_VECTOR(13)									//	Определяем вектор прерываний по событию установки флага OCF2A
	#define TIMER2_COMPB_vect_num	14											//	Определяем номер  вектора  для  события установки флага OCF2B
	#define TIMER2_COMPB_vect		_VECTOR(14)									//	Определяем вектор прерываний по событию установки флага OCF2B
	#define TIMER2_OVF_vect_num		15											//	Определяем номер  вектора  для  события установки флага TOV2
	#define TIMER2_OVF_vect			_VECTOR(15)									//	Определяем вектор прерываний по событию установки флага TOV2
#endif																			//
#endif																			//
																				//
#define	IR_UNDEFINED				0											//			тип кодирования не определён
#define	IR_PAUSE_LENGTH				1											//			кодирование длинной паузы
#define	IR_PULSE_LENGTH				2											//			кодирование шириной импульса (ШИМ)
#define	IR_BIPHASIC					3											//			бифазное кодирование
#define	IR_BIPHASIC_INV				4											//			бифазное кодирование с инверсными битами
#define	IR_NRC						5											//	NOKIA	бифазное кодирование с сигналом старт, пакеты повтора идентичны, первый и последний пакеты специальные
#define	IR_RS5						6											//	PHILIPS	бифазное кодирование с битом toggle (третий бит в пакете), пакеты повтора идентичны первому
#define	IR_RS5X						7											//	PHILIPS	бифазное кодирование с битом toggle (второй бит в пакете), пакеты повтора идентичны первому
#define	IR_RS6						8											//	PHILIPS	бифазное кодирование с битом toggle (пятый бит в пакете) и сигналом старт, пакеты повтора идентичны первому
#define	IR_CLEAN					255											//	сброс, ранее установленного, протокола передачи данных
																				//
#define	IR_INTERVAL_PACK			7											//	минимальный интервал между повторными пакетами в мс
#define	IR_INTERVAL_PRESS			150											//	минимальный интервал между нажатиями клавиш в мс
																				//
class iarduino_IR_VV{															//	класс volatile variable
	public:																		//
	/**	переменные изменяемые в прерываниях **/									//
		volatile	uint8_t			IRRX_pins_NUM			=	0;				//	номер вывода к которому подключён ИК-приёмник
		volatile	uint8_t			IRTX_pins_NUM			=	0;				//	номер вывода к которому подключён ИК-светодиод
		volatile	uint8_t			IRRX_uint_READ_STATUS	=	0;				//	состояние приёма пакетов
																				//	0 - нет пакетов
																				//	1 - принимается первый пакет	3 - принимается второй пакет
																				//	2 - принят первый пакет			4 - принят второй пакет
																				//	5 - принимаются или приняты следующие пакеты
																				//	6 - пауза после последнего пакета превышает IR_INTERVAL_PRESS мс
		volatile	bool			IRTX_pins_SEND_STATUS	=	0;				//	состояние передачи несущей частоты (не передаётся/передаётся)
		volatile	bool			IRRX_pins_READ_DATA		=	0;				//	состояние на выводе к которому подключён ИК приёмник
		volatile	bool			IRTX_pins_SEND_DATA		=	0;				//	состояние на выводе к которому подключён светодиод (0/1)
		volatile	bool			IRRX_flag_CHECK			=	0;				//	флаг выполнения функции check (для реализации опции НЕреагирования на повторные пакеты)
		volatile	bool			IRRX_flag_KEY_PRESS		=	0;				//	флаг выполнения функции check (для установки флага key_press доступного пользователю)
		volatile	bool			IRRX_flag_READ_REPEAT	=	0;				//	флаг наличия повторного пакета старше второго (удерживается клавиша на пульте)
		volatile	bool			IRRX_flag_READ_PULSE	=	0;				//	флаг состояния сигнала в данный момент времени (1-PULSE/0-PAUSE)
		volatile	bool			IRRX_flag_READ_INVERT	=	0;				//	флаг инвертирования сигналов принимаемых от ИК приёмника
		volatile	bool			IRTX_flag_SEND_INVERT	=	0;				//	флаг инвертирования сигналов передаваемых на светодиод
		volatile	bool			IRXX_flag_SEND			=	0;				//	флаг передачи данных
		volatile	uint16_t		IRRX_uint_PACK_PAUSE	=	0;				//	пауза между 1 и 2 пакетами
		volatile	uint8_t			IRTX_uint_CALL_PAUSE	=	0;				//	пауза между вызовами функции send (в мкс/50)
		volatile	uint16_t		IRRX_uint_PACK_LENGTH	=	0;				//	длинна сигнала или паузы принимаемой в данный момент времени (в мкс/50)
		volatile	uint8_t			IRRX_uint_PACK_INDEX	=	0;				//	индекс в массиве с данными, в который сейчас записывается время
		volatile	uint8_t			IRRX_uint_PACK_NUM		=	0;				//	номер массива в который записывается пакет
		volatile	uint8_t			IRRX_uint_PACK_LEN[2]	=	{0,0};			//	длинна   массива с данными 1 и 2 пакета
		volatile	uint8_t			IRRX_mass_PACK[2][68];						//	массив с данными 1 и 2 пакета (длительность импульсов и паузы, в мкс/50)
};																				//
																				//
class iarduino_IR_XX{															//	класс общих функций
	public:																		//
					void			IRXX_func_TIMER2_SETREG(uint32_t);			//	установка значений регистров таймера под нужную частоту (частота в кГц)
					uint8_t			IRXX_func_DECODING(const char *i,uint8_t);	//
};																				//
																				//
#endif																			//